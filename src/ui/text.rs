use gl::types::*;
use glam::{Mat4, Vec3};
use std::mem;

use crate::renderer::shader::ShaderProgram;

const TEXT_VERT_SRC: &str = include_str!("../../shaders/text.vert");
const TEXT_FRAG_SRC: &str = include_str!("../../shaders/text.frag");

const GLYPH_W: u32 = 8;
const GLYPH_H: u32 = 8;
const ATLAS_COLS: u32 = 16;
const ATLAS_ROWS: u32 = 6;
const ATLAS_W: u32 = ATLAS_COLS * GLYPH_W; // 128
const ATLAS_H: u32 = ATLAS_ROWS * GLYPH_H; // 48

// 4 floats per vertex (x, y, u, v), 6 vertices per quad
const FLOATS_PER_CHAR: usize = 4 * 6;
const MAX_CHARS: usize = 256;

/// Embedded 8x8 bitmap font covering ASCII 32â€“127.
/// Each byte represents one row of a glyph (MSB = leftmost pixel).
#[rustfmt::skip]
const FONT_8X8: [u8; 96 * 8] = [
    // 32: space
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 33: !
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 34: "
    0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 35: #
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // 36: $
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
    // 37: %
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    // 38: &
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // 39: '
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 40: (
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // 41: )
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // 42: *
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // 43: +
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // 44: ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 45: -
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // 46: .
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 47: /
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 48: 0
    0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00,
    // 49: 1
    0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 50: 2
    0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00,
    // 51: 3
    0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 52: 4
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00,
    // 53: 5
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 54: 6
    0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 55: 7
    0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    // 56: 8
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 57: 9
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    // 58: :
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // 59: ;
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // 60: <
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // 61: =
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // 62: >
    0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
    // 63: ?
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // 64: @
    0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00,
    // 65: A
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // 66: B
    0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00,
    // 67: C
    0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00,
    // 68: D
    0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
    // 69: E
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00,
    // 70: F
    0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
    // 71: G
    0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00,
    // 72: H
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // 73: I
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 74: J
    0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00,
    // 75: K
    0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00,
    // 76: L
    0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00,
    // 77: M
    0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    // 78: N
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // 79: O
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 80: P
    0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // 81: Q
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // 82: R
    0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
    // 83: S
    0x7C, 0xC6, 0xE0, 0x7C, 0x0E, 0xC6, 0x7C, 0x00,
    // 84: T
    0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 85: U
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 86: V
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // 87: W
    0xC6, 0xC6, 0xD6, 0xFE, 0xFE, 0xEE, 0xC6, 0x00,
    // 88: X
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // 89: Y
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00,
    // 90: Z
    0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
    // 91: [
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
    // 92: backslash
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // 93: ]
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
    // 94: ^
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // 95: _
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    // 96: `
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 97: a
    0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
    // 98: b
    0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00,
    // 99: c
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
    // 100: d
    0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    // 101: e
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // 102: f
    0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x78, 0x00,
    // 103: g
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x78,
    // 104: h
    0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00,
    // 105: i
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 106: j
    0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C,
    // 107: k
    0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
    // 108: l
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // 109: m
    0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xD6, 0x00,
    // 110: n
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00,
    // 111: o
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // 112: p
    0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0,
    // 113: q
    0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E,
    // 114: r
    0x00, 0x00, 0xDC, 0x76, 0x60, 0x60, 0xF0, 0x00,
    // 115: s
    0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
    // 116: t
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
    // 117: u
    0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
    // 118: v
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    // 119: w
    0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00,
    // 120: x
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
    // 121: y
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0xFC,
    // 122: z
    0x00, 0x00, 0xFE, 0x8C, 0x18, 0x32, 0xFE, 0x00,
    // 123: {
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
    // 124: |
    0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
    // 125: }
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
    // 126: ~
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // 127: DEL (blank)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

pub struct TextRenderer {
    shader: ShaderProgram,
    vao: GLuint,
    vbo: GLuint,
    font_texture: GLuint,
}

impl TextRenderer {
    pub fn new() -> Self {
        let shader = ShaderProgram::from_sources(TEXT_VERT_SRC, TEXT_FRAG_SRC)
            .expect("Failed to compile text shaders");

        // Build font atlas from embedded bitmap data
        let mut atlas = vec![0u8; (ATLAS_W * ATLAS_H) as usize];
        for ch_idx in 0..96u32 {
            let col = ch_idx % ATLAS_COLS;
            let row = ch_idx / ATLAS_COLS;
            for y in 0..GLYPH_H {
                let byte = FONT_8X8[(ch_idx * 8 + y) as usize];
                for x in 0..GLYPH_W {
                    let pixel = if byte & (0x80 >> x) != 0 { 255 } else { 0 };
                    let atlas_x = col * GLYPH_W + x;
                    let atlas_y = row * GLYPH_H + y;
                    atlas[(atlas_y * ATLAS_W + atlas_x) as usize] = pixel;
                }
            }
        }

        let mut font_texture: GLuint = 0;
        let mut vao: GLuint = 0;
        let mut vbo: GLuint = 0;

        unsafe {
            // Upload R8 texture
            gl::GenTextures(1, &mut font_texture);
            gl::BindTexture(gl::TEXTURE_2D, font_texture);
            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);
            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::R8 as i32,
                ATLAS_W as i32,
                ATLAS_H as i32,
                0,
                gl::RED,
                gl::UNSIGNED_BYTE,
                atlas.as_ptr() as *const _,
            );
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::NEAREST as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::NEAREST as i32);
            gl::TexParameteri(
                gl::TEXTURE_2D,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_2D,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );

            // Create VAO/VBO for dynamic text quads
            gl::GenVertexArrays(1, &mut vao);
            gl::GenBuffers(1, &mut vbo);

            gl::BindVertexArray(vao);
            gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
            gl::BufferData(
                gl::ARRAY_BUFFER,
                (MAX_CHARS * FLOATS_PER_CHAR * mem::size_of::<f32>()) as GLsizeiptr,
                std::ptr::null(),
                gl::DYNAMIC_DRAW,
            );

            let stride = (4 * mem::size_of::<f32>()) as GLsizei;
            // a_pos (location 0)
            gl::EnableVertexAttribArray(0);
            gl::VertexAttribPointer(0, 2, gl::FLOAT, gl::FALSE, stride, std::ptr::null());
            // a_texcoord (location 1)
            gl::EnableVertexAttribArray(1);
            gl::VertexAttribPointer(
                1,
                2,
                gl::FLOAT,
                gl::FALSE,
                stride,
                (2 * mem::size_of::<f32>()) as *const _,
            );

            gl::BindVertexArray(0);
        }

        Self {
            shader,
            vao,
            vbo,
            font_texture,
        }
    }

    pub fn draw_text(
        &mut self,
        text: &str,
        x: f32,
        y: f32,
        scale: f32,
        color: Vec3,
        projection: &Mat4,
    ) {
        let gw = GLYPH_W as f32 * scale;
        let gh = GLYPH_H as f32 * scale;
        let atlas_w = ATLAS_W as f32;
        let atlas_h = ATLAS_H as f32;

        let mut vertices: Vec<f32> = Vec::with_capacity(text.len().min(MAX_CHARS) * FLOATS_PER_CHAR);
        let mut cursor_x = x;

        for ch in text.chars().take(MAX_CHARS) {
            let idx = ch as u32;
            if !(32..=127).contains(&idx) {
                cursor_x += gw;
                continue;
            }
            let glyph_idx = idx - 32;
            let col = glyph_idx % ATLAS_COLS;
            let row = glyph_idx / ATLAS_COLS;

            let u0 = (col * GLYPH_W) as f32 / atlas_w;
            let v0 = (row * GLYPH_H) as f32 / atlas_h;
            let u1 = ((col + 1) * GLYPH_W) as f32 / atlas_w;
            let v1 = ((row + 1) * GLYPH_H) as f32 / atlas_h;

            let x0 = cursor_x;
            let y0 = y;
            let x1 = cursor_x + gw;
            let y1 = y + gh;

            // Two triangles per quad
            #[rustfmt::skip]
            vertices.extend_from_slice(&[
                x0, y0, u0, v0,
                x1, y0, u1, v0,
                x1, y1, u1, v1,

                x0, y0, u0, v0,
                x1, y1, u1, v1,
                x0, y1, u0, v1,
            ]);

            cursor_x += gw;
        }

        if vertices.is_empty() {
            return;
        }

        unsafe {
            self.shader.bind();
            self.shader.set_mat4("u_projection", projection);
            self.shader.set_vec3("u_text_color", color);

            gl::ActiveTexture(gl::TEXTURE0);
            gl::BindTexture(gl::TEXTURE_2D, self.font_texture);
            self.shader.set_int("u_font_atlas", 0);

            gl::BindVertexArray(self.vao);
            gl::BindBuffer(gl::ARRAY_BUFFER, self.vbo);
            gl::BufferSubData(
                gl::ARRAY_BUFFER,
                0,
                (vertices.len() * mem::size_of::<f32>()) as GLsizeiptr,
                vertices.as_ptr() as *const _,
            );

            gl::DrawArrays(gl::TRIANGLES, 0, (vertices.len() / 4) as i32);
            gl::BindVertexArray(0);
        }
    }

    pub fn measure_text(&self, text: &str, scale: f32) -> f32 {
        let gw = GLYPH_W as f32 * scale;
        text.chars().take(MAX_CHARS).count() as f32 * gw
    }
}

impl Drop for TextRenderer {
    fn drop(&mut self) {
        unsafe {
            gl::DeleteVertexArrays(1, &self.vao);
            gl::DeleteBuffers(1, &self.vbo);
            gl::DeleteTextures(1, &self.font_texture);
        }
    }
}
